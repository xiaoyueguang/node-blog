# 利用 Node.js 一步步搭建 Blog 系统(四)

> 本系列文章将利用 `Node.js` 一步步搭建一个博客系统, 包含浏览、 查看、注册、登录、回复、点赞、文章管理等功能. 客户端包括pc、app、wap等

往期文章回顾  
[<利用 Node.js 一步步搭建 Blog 系统(一)>](https://github.com/xiaoyueguang/blog/blob/master/docs/1.md)  
[<利用 Node.js 一步步搭建 Blog 系统(二)>](https://github.com/xiaoyueguang/blog/blob/master/docs/2.md)  
[<利用 Node.js 一步步搭建 Blog 系统(三)>](https://github.com/xiaoyueguang/blog/blob/master/docs/3.md)  

这篇文章中, 将开始使用MySQL数据库, 并封装出相应的方法, 同时能够对数据库进行一些操作.

## MySQL
在这个应用中, 我们采用`MySQL`作为数据库. `MySQL`作为一个关系型数据库管理系统, 同时具有关系型数据库的特点:
1. 数据以表格形式存储.
2. 表格的行和列分别代表数据名和数据域.
3. 多个行列形成一个表.
4. 多个表形成一个数据库.

***
## 对数据库进行操作

因为我们这个只是个简单的博客应用, 因此不需要有创建数据库或创建数据表的操作. 这些我们通过一些数据库工具来完成. 我们只关心怎么对表的插入, 更新, 查询和删除, 数据库通过执行`SQL`语句来操作数据库.  
首先先了解下以上的行为, 在数据库上是如何通过`SQL`来操作数据库的.

|SQL|说明|
|:--|:--|
|插入语句||
|`insert into article values (NULL, '标题', '内容')`|添加数据, 数据库会按照顺序添加进去. 值必须跟字段名数量一致!|
|`insert into article (title) values ('标题')`|插入一条数据, 且只给title字段添加数据|
|`insert into article (title, content) values ('标题', '内容'), ('标题', '内容')`|插入多条数据|
|查询语句||
|`select * from article`|查询全部数据|
|`select id, title as TITLE from article`|按字段查询, 且给字段重命名|
|`select * from article where title = '标题' AND content = '内容'`|条件查询|
|`select * from article where id >= '4' OR id < '3'`|条件查询|
|`select * from article where title like '标%'`|模糊查询. %表示从哪里匹配|
|`select * from article order by id desc`|按id降序查询|
|更新语句||
|`update article set content = default`|更新全部内容|
|`update article set content = '内容1' where id = '1'`|按照条件 更新一个字段|
|`update article set content = '内容1', title = '标题1' where id = '1'`|按照条件 更新多个字段|
|`update user set age = age + 1`|将某个字段全部加1|
|删除语句||
|`delete from article`|删除表中所有数据|
|`delete from article where id = 1`|删除id为1的文章|

查询语句除了上面的查询, 其实还有很多, 比如  
1. `select article.id, article.title, content.content from article left join content on article.content_id = content.id` 按照文章进行查询, 同时根据content_id查询对应的内容
2. `select article.id, article.title, content.content from content right join article on article.content_id = content.id` 与上面的左连接有所区分. 显示右边表的所有数据, 并将左边表的数据添加上去
3. `select article.id, article.title, comments.content as comments from article inner join comments on article.id = comments.article_id` 按照文章进行查询, 并且显示对应的评论. 如果两者无关系, 则不显示
4. `select article.id, article.title, comments.content as comments from article, comments where article.id = comments.article_id` 与上面结果返回类似
5. `select content from article union select content from comments` 返回文章和评论所有的内容, 并去重
6. `select content from article union all select content from comments` 返回文章和评论所有的内容, 不去重

了解了基本的`SQL`后, 发现动态的生成`SQL`语句很关键, 操作数据库的流程可变成
```
生成SQL => 执行SQL
```

### 如何生成SQL
生成`SQL`又可以分为四种操作, `insert`, `select`, `update`, 和 `delete`, 每种生成的`SQL`结构都大不一样, 因此需要有这四个对应的方法, 将实例化后的类中的其他属性转换成对应的`SQL`.  
这四种操作都需要`table`, 即表名. 因此我们的`DB`类中需要一个私有`table`属性以及设置table的方法.  
查询, 更新和删除 都有可能需要条件, 因此还得有个私有`where`属性以及设置where的方法. `order`也是如此.  
于是一个简单的`DB`类出来了. 通过每次的实例化, 能得到相应的数据.
```
class DB {
  constructor () {
    this._table = ''
    this._where = ''
    this._order = ''
  }

  table (table) {
    this._table = table
  }

  where (where) {
    this._where = where
  }

  order (order) {
    this._order = order
  }

  select (fields) {}
  update (data) {}
  delete () {}
  insert (data) {}
}
```
调用的时候就是
```
let db = new DB()
db.table('article')
db.where('id = 1')
db.where('id = 2', 'or')
db.select('*')
db._sql // => select * from article where id = 1 or id = 2
```
每次调用方法, 都需要从对象上调用, 使用起来很麻烦. 不如给每个方法返回自身, 这样就能实现链式调用, 看起来也更加简洁. 上面的步骤, 最后步通过传入的参数来生成对应的`SQL`.  
具体的实现点击这两个链接[dbCore](https://github.com/xiaoyueguang/blog/blob/master/server/Core/dbCore.js), [dbCore.test](https://github.com/xiaoyueguang/blog/blob/master/server/test/Core/dbCore.test.js)

